##### [üá´üá∑ Version fran√ßaise](README.fr.md) / [üá¨üáß English version](README.md)

# PROJET WEBSERV POUR 42
Par **chdonnat** (Christophe Donnat, 42 Perpignan ‚Äì France)

Avec mes co-√©quipiers : **Olivier Thorel** et **Lucas Matkowski**, √©galement de 42 Perpignan ‚Äì France.

<p align="center">
  <img src="https://github.com/donnatchris/webserv/blob/main/screenshots/index.png" width="30%" height="200px" />
  <img src="https://github.com/donnatchris/webserv/blob/main/screenshots/webserv.png" width="30%" height="200px" />
  <img src="https://github.com/donnatchris/webserv/blob/main/screenshots/siege_results.png" width="30%" height="200px" />
</p>


## BUT DU PROJET :

**Webserv** est un projet d'√©quipe (3 membres) qui consiste √† cr√©er un serveur HTTP enti√®rement fonctionnel en C++, conforme √† la sp√©cification HTTP/1.1 (RFC 2616).
Le serveur doit √™tre capable de :
- Parser et appliquer plusieurs fichiers de configuration
- G√©rer les m√©thodes HTTP : GET, POST, et DELETE
- Servir des fichiers statiques et g√©n√©rer des pages d'autoindex
- Ex√©cuter des scripts CGI
- Supporter plusieurs serveurs virtuels
- G√©rer plusieurs connexions simultan√©es en utilisant `poll()`

L'objectif est d'acqu√©rir une compr√©hension approfondie du fonctionnement interne des serveurs web, et d'impl√©menter la programmation de sockets de bas niveau et le multiplexage d'E/S en C++98.


## PARTIE BONUS :

Les fonctionnalit√©s bonus suivantes ont √©t√© impl√©ment√©es :
- Gestion des sessions bas√©e sur les cookies
- Support de multiples CGI (dans notre projet : Python et PHP)

Ces bonus d√©montrent une ma√Ætrise plus approfondie des m√©canismes HTTP et refl√®tent le fonctionnement des applications web du monde r√©el.


## CE DONT NOUS SOMMES FIERS :

Comme nous avons vraiment appr√©ci√© travailler sur le projet, nous sommes all√©s plus loin et avons impl√©ment√© :
- Compatibilit√© totale avec **macOS** et **Linux**
- Support de l'upload de fichiers via `multipart/form-data` (limit√© √† un fichier √† la fois), permettant l'envoi de n'importe quel type de fichier (PNG, PDF, MP3, etc.)
- Communication "chunked" (par blocs de 4096 octets), y compris pour les uploads, afin d'optimiser l'utilisation de la m√©moire
- Un point d'entr√©e unique : la classe `Server` communique avec `ProcessRequest` exclusivement via sa m√©thode `process()`, g√©rant de mani√®re transparente les donn√©es entrantes et les r√©ponses sortantes
- Un **site web de test complet et amusant sur le th√®me des zombies** pour d√©montrer et valider toutes les fonctionnalit√©s
- R√©sultats des tests de charge (load testing) avec Siege : 100% de succ√®s sur plus de 250 000 transactions en 1 minute.


## QUELQUES COMMANDES UTILES :

Compiler le programme et supprimer les fichiers .o :

	make && make clean

 ---

Ex√©cuter le programme avec le fichier de configuration par d√©faut :

(lancer le programme sans argument utilise le fichier de configuration `config/default.conf`)

	./webserv webserv.conf

Avec ce fichier de configuration, vous pouvez maintenant tester un site web que nous avons cr√©√© pour tester l'ensemble du projet :

Dans votre navigateur pr√©f√©r√©, tapez :

	http://localhost:8000

 ---

 Ex√©cuter le programme avec un autre fichier de configuration

	./webserv config/

Avec ce fichier de configuration, vous pouvez maintenant tester 3 serveurs virtuels, chacun avec son propre site de test.

  Dans votre navigateur pr√©f√©r√©, tapez :

	http://localhost:8000

 	http://localhost:80808

  	http://localhost:8888

## TEST DE CHARGE AVEC SIEGE

Le test de charge ("load testing") est une m√©thode utilis√©e pour √©valuer les performances d'un serveur web sous un trafic √©lev√©.
Il simule de nombreux clients effectuant des requ√™tes simultan√©ment pour v√©rifier la stabilit√©, le temps de r√©ponse et le d√©bit du serveur.
Siege est un outil en ligne de commande populaire pour effectuer de tels tests.
Il est gratuit et disponible sur la plupart des syst√®mes ‚Äî vous pouvez l'installer avec un gestionnaire de paquets comme `brew install siege` (macOS) ou `sudo apt install siege` (Linux).

Une commande de base pour lancer un test de charge sur notre serveur serait (dans un autre terminal pendant que le serveur tourne) :

```bash
siege -v http://localhost:8888
```

**Attention** : Assurez-vous de tester un serveur qui ne contient pas de liens externes (par exemple, Google Fonts ou des ressources CDN).
Siege suivra ces liens et enverra des requ√™tes √† des serveurs tiers, ce qui est non seulement inappropri√© (et potentiellement ill√©gal), mais provoquera √©galement des transactions √©chou√©es sans rapport avec votre propre serveur.

> Pour notre Webserv, lors de l'utilisation du fichier de configuration `config/webserv.conf`, veillez √† ne tester que le serveur sur le port 8888, car celui sur le port 8000 peut inclure des liens externes vers les serveurs de Google (pour les polices).

**Nous avons mis Webserv √† l'√©preuve avec un trafic intense ‚Äî et il a tenu la charge. Voici les r√©sultats :**
```
Lifting the server siege...
Transactions:		   262650    hits
Availability:		      100.00 %
Elapsed time:		       60.98 secs
Data transferred:	      399.02 MB
Response time:		        5.77 ms
Transaction rate:	     4307.15 trans/sec
Throughput:		        6.54 MB/sec
Concurrency:		       24.86
Successful transactions:   262650
Failed transactions:	        0
Longest transaction:	       40.00 ms
Shortest transaction:	        0.00 ms
```


## ARCHITECTURE :

- `config/` ‚Äî Contient des exemples de fichiers de configuration utilis√©s pour tester le projet.
- `documentation_fr/` ‚Äî Documentation et notes techniques en fran√ßais.
- `include/` ‚Äî Tous les fichiers d'en-t√™te (.hpp) du projet.
- `screenshots` - Captures d'√©cran du projet.
- `src/` ‚Äî Code source du serveur, organis√© par responsabilit√© :
  - `config/` ‚Äî Classes pour le parsing et le stockage des donn√©es de configuration.
  - `http/` ‚Äî Classes pour le parsing des requ√™tes HTTP et la construction des r√©ponses HTTP.
  - `process/` ‚Äî Classes pour le traitement des donn√©es client et la gestion de la logique de communication.
  - `server/` ‚Äî Classes pour la gestion des sockets, des connexions et de la boucle principale du serveur.
- `www/` ‚Äî Contient les fichiers statiques et les sites de test (HTML, CSS, images et scripts CGI).
- `Makefile` ‚Äî Syst√®me de build avec les r√®gles suivantes : `make`, `bonus`, `clean`, `fclean`, `re`.
- `README.md` ‚Äî Pr√©sentation du projet et instructions d'utilisation cl√©s.


## CLASSES ET RESPONSABILIT√âS

Webserv est structur√© autour de classes modulaires √† responsabilit√© unique qui collaborent pour traiter efficacement les requ√™tes HTTP :

- **`Server`**
  Le point d'entr√©e du serveur. Il ouvre les sockets d'√©coute, g√®re les connexions et pilote la boucle d'√©v√©nements principale √† l'aide d'un m√©canisme de multiplexage (`poll`, `epoll`, etc.). Il interagit avec chaque client via la m√©thode `ProcessRequest::process()`.

- **`PollManager`**
  Un wrapper autour de l'API de multiplexage au niveau de l'OS (`poll`, `kqueue`, etc.). Il abstrait l'enregistrement des descripteurs de fichiers, la disponibilit√© des √©v√©nements (POLLIN/POLLOUT) et la distribution des √©v√©nements, garantissant des E/S non bloquantes efficaces.

- **`Connection`**
  Repr√©sente une connexion client. Elle stocke le socket client, suit son √©tat de lecture/√©criture et d√©l√®gue le traitement des donn√©es √† une instance de `ProcessRequest`.

- **`ProcessRequest`**
  Au c≈ìur du traitement des requ√™tes. Il expose une interface unique `process()` utilis√©e par le serveur √† la fois pour la r√©ception et l'envoi de donn√©es. Il orchestre le parsing, la r√©partition logique, l'ex√©cution CGI et la pr√©paration de la r√©ponse.

- **`RequestParser`**
  Transforme les donn√©es brutes en un objet `HttpRequest` valide. Il g√®re les en-t√™tes, le "chunked transfer encoding", le `Content-Length` et les entr√©es invalides avec √©l√©gance.

- **`HttpRequest`**
  Contient une requ√™te HTTP enti√®rement pars√©e : m√©thode, URI, en-t√™tes et corps optionnel. Utilis√© par `ProcessRequest` pour prendre des d√©cisions de routage et de logique.

- **`HttpResponse`**
  Construit la r√©ponse HTTP ligne par ligne : statut, en-t√™tes et corps. Il prend en charge les types de contenu, la longueur du contenu, la redirection et le formatage des erreurs.

- **`ResponseBuilder`**
  (H√©rit√© / aide) Aide √† la construction des r√©ponses HTTP avant d'√™tre remplac√© ou int√©gr√© dans `ProcessRequest` pour le formatage final.

- **`CGIHandler`**
  Ex√©cute les scripts CGI (par exemple, Python, PHP). Il configure les variables d'environnement, g√®re les pipes et la redirection des E/S, et lit la sortie du script pour construire une r√©ponse HTTP valide.

- **`File`**
  G√®re l'acc√®s aux fichiers sur le disque. Valide les permissions, d√©termine les types MIME et g√®re les lectures/√©critures "chunked" pour un service de fichiers efficace.

- **`ConfigParser`**
  Lit et tokenise le fichier `.conf`. Il extrait les blocs (`server`, `location`) et les directives (`listen`, `root`, etc.) dans une structure interne.

- **`ConfigValidator`**
  V√©rifie la configuration pars√©e pour sa correction s√©mantique : adresses IP valides, ports, doublons, directives manquantes et int√©grit√© structurelle.

- **`ServerConfig` / `Location`**
  Repr√©sentent la configuration hi√©rarchique du serveur. `ServerConfig` contient les param√®tres globaux et par serveur ; `Location` d√©finit les surcharges et les comportements sp√©cifiques √† un chemin.

- **`HttpErrorException`**
  Une exception personnalis√©e utilis√©e pour signaler les erreurs au niveau HTTP pendant le traitement des requ√™tes (par exemple, 404 Not Found, 405 Method Not Allowed), permettant une gestion propre des erreurs et la g√©n√©ration de r√©ponses.

---

## DOCUMENTATION

Contrairement √† la plupart de mes projets, vous trouverez une **documentation et des notes techniques en fran√ßais** dans le r√©pertoire `documentation_fr/`.

Ce r√©pertoire contient les fichiers suivants, r√©dig√©s pendant notre phase de recherche avant de nous lancer dans l'impl√©mentation :

- `CGI.fr.md` ‚Äî Une explication rapide de ce qu'est le CGI et de son fonctionnement
- `fichiers_de_config.fr.md` ‚Äî Une analyse de ce qui doit √™tre g√©r√© dans les fichiers de configuration pour un serveur conforme
- `fonctions_doc` ‚Äî Un r√©pertoire contenant des fichiers avec des listes et des explications de toutes les fonctions C autoris√©es dans le projet
- `HTTP1.1.fr.md` ‚Äî Une version r√©sum√©e et accessible de la RFC 2616, qui d√©finit le protocole HTTP/1.1
- `webserv_doc.fr.md` ‚Äî Un aper√ßu complet de tous les concepts cl√©s requis pour le projet - Vous devriez absolument commencer par ici si vous √™tes sur le point de r√©aliser ce projet.


Vous trouverez ci-dessous un r√©sum√© des principaux concepts que vous devez comprendre pour travailler sur le projet. La suite de ce document constitue un r√©sum√© de ces fichiers.

---

### Un serveur Web en C++

#### D√©finition

Un serveur web est un programme qui :

- √âcoute les requ√™tes HTTP des clients (comme les navigateurs)
- Parse ces requ√™tes
- Recherche la ressource demand√©e (fichier, script, etc.)
- Et renvoie une r√©ponse HTTP structur√©e, g√©n√©ralement du HTML ou un autre contenu.

> En bref, un serveur web est un traducteur entre un client qui pose une question et un syst√®me de fichiers ou un environnement d'ex√©cution qui fournit la r√©ponse.

#### Fichier de Configuration

Le programme Webserv doit √™tre lanc√© avec le chemin d'un fichier de configuration en argument. C'est un **fichier texte brut**, g√©n√©ralement avec l'extension `.conf`, qui d√©crit **comment le serveur web doit se comporter**, et doit √™tre pars√© √† l'ex√©cution.
Le programme doit **lire ce fichier** et **configurer dynamiquement le serveur** selon son contenu.

> Si le programme est lanc√© sans argument, il doit utiliser un fichier de configuration par d√©faut situ√© √† un chemin connu cod√© en dur (par exemple : `"./default.conf"` ou `"/etc/webserv.conf"`).

Il n'y a pas de grammaire strictement impos√©e pour les fichiers de configuration, mais dans Webserv, nous suivons principalement le style des **fichiers de configuration NGINX**, car NGINX est un serveur web l√©ger et hautement configurable. Ceux-ci sont structur√©s avec :

1.  **Blocs** (par ex., `server`, `location`)
2.  **Directives** (par ex., `listen`, `root`, `index`) se terminant par `;`
3.  Une **structure hi√©rarchique logique**

***‚Üí Les fichiers de configuration sont expliqu√©s en d√©tail dans le fichier `fichiers_de_config.fr.md`***

#### 1. √âcoute

Le serveur ouvre un **socket TCP** sur un **port** (g√©n√©ralement 80 ou 8080) pour attendre les connexions entrantes.

#### 2. Acceptation

Le serveur accepte une connexion et re√ßoit une requ√™te HTTP, par exemple :

	GET /index.html HTTP/1.1
	Host: localhost


#### 3. Parsing

Le serveur analyse la requ√™te :

- M√©thode (`GET`, `POST`, etc.)
- Chemin (`/index.html`)
- En-t√™tes (`Host`, `Content-Type`, etc.)

#### 4. R√©ponse

Le serveur construit une r√©ponse HTTP incluant :

- Une **ligne de statut** (`HTTP/1.1 200 OK`)
- Des **en-t√™tes** (`Content-Type`, `Content-Length`, etc.)
- Un **corps** (souvent du HTML, du JSON ou une image)

#### 5. Gestion de Plusieurs Clients

Il doit √™tre capable de g√©rer **plusieurs connexions simultan√©es** sans bloquer.

#### 6. Ex√©cution de Scripts (CGI)

Si la requ√™te cible un script (par ex., `.py`, `.php`), le serveur doit :

- Cr√©er un processus enfant avec `fork()`
- Ex√©cuter le script avec `execve()`
- Capturer sa sortie
- Envoyer cette sortie comme r√©ponse

#### R√©sum√© de Webserv

En r√©sum√©, le programme Webserv doit √™tre capable de :

- Lire et appliquer un fichier de configuration
- √âcouter sur des sockets
- Comprendre le protocole HTTP (requ√™tes/r√©ponses)
- Ouvrir et lire des fichiers
- Ex√©cuter des scripts CGI
- G√©rer les erreurs (404, 500, etc.)
- Supporter plusieurs serveurs configurables

---

### Un serveur Web en C++

#### D√©finition

Un serveur web est un programme qui :

- √âcoute les requ√™tes HTTP des clients (comme les navigateurs)
- Parse ces requ√™tes
- Recherche la ressource demand√©e (fichier, script, etc.)
- Et renvoie une r√©ponse HTTP structur√©e, g√©n√©ralement du HTML ou un autre contenu.

> En bref, un serveur web est un traducteur entre un client qui pose une question et un syst√®me de fichiers ou un environnement d'ex√©cution qui fournit la r√©ponse.

#### Fichier de Configuration

Le programme Webserv doit √™tre lanc√© avec le chemin d'un fichier de configuration en argument. C'est un **fichier texte brut**, g√©n√©ralement avec l'extension `.conf`, qui d√©crit **comment le serveur web doit se comporter**, et doit √™tre pars√© √† l'ex√©cution.
Le programme doit **lire ce fichier** et **configurer dynamiquement le serveur** selon son contenu.

> Si le programme est lanc√© sans argument, il doit utiliser un fichier de configuration par d√©faut situ√© √† un chemin connu cod√© en dur (par exemple : `"./default.conf"` ou `"/etc/webserv.conf"`).

Il n'y a pas de grammaire strictement impos√©e pour les fichiers de configuration, mais dans Webserv, nous suivons principalement le style des **fichiers de configuration NGINX**, car NGINX est un serveur web l√©ger et hautement configurable. Ceux-ci sont structur√©s avec :

1.  **Blocs** (par ex., `server`, `location`)
2.  **Directives** (par ex., `listen`, `root`, `index`) se terminant par `;`
3.  Une **structure hi√©rarchique logique**

***‚Üí Les fichiers de configuration sont expliqu√©s en d√©tail dans le fichier `fichiers_de_config.fr.md`***

#### 1. √âcoute

Le serveur ouvre un **socket TCP** sur un **port** (g√©n√©ralement 80 ou 8080) pour attendre les connexions entrantes.

#### 2. Acceptation

Le serveur accepte une connexion et re√ßoit une requ√™te HTTP, par exemple :

	GET /index.html HTTP/1.1
	Host: localhost


#### 3. Parsing

Le serveur analyse la requ√™te :

- M√©thode (`GET`, `POST`, etc.)
- Chemin (`/index.html`)
- En-t√™tes (`Host`, `Content-Type`, etc.)

#### 4. R√©ponse

Le serveur construit une r√©ponse HTTP incluant :

- Une **ligne de statut** (`HTTP/1.1 200 OK`)
- Des **en-t√™tes** (`Content-Type`, `Content-Length`, etc.)
- Un **corps** (souvent du HTML, du JSON ou une image)

#### 5. Gestion de Plusieurs Clients

Il doit √™tre capable de g√©rer **plusieurs connexions simultan√©es** sans bloquer.

#### 6. Ex√©cution de Scripts (CGI)

Si la requ√™te cible un script (par ex., `.py`, `.php`), le serveur doit :

- Cr√©er un processus enfant avec `fork()`
- Ex√©cuter le script avec `execve()`
- Capturer sa sortie
- Envoyer cette sortie comme r√©ponse

#### R√©sum√© de Webserv

En r√©sum√©, le programme Webserv doit √™tre capable de :

- Lire et appliquer un fichier de configuration
- √âcouter sur des sockets
- Comprendre le protocole HTTP (requ√™tes/r√©ponses)
- Ouvrir et lire des fichiers
- Ex√©cuter des scripts CGI
- G√©rer les erreurs (404, 500, etc.)
- Supporter plusieurs serveurs configurables

---

### Quelques D√©finitions de Base

#### Client

> Un **client** est un programme (souvent un **navigateur web**) qui envoie une **requ√™te HTTP** √† un serveur web pour demander une **ressource** (page HTML, image, fichier, script, etc.).

Dans le contexte de Webserv :

- Le **client** se connecte au serveur Webserv via le r√©seau
- Il envoie une requ√™te
- Il attend une r√©ponse HTTP

#### Requ√™te HTTP

> Une **requ√™te HTTP** est un **message textuel** envoy√© par un client √† un serveur pour demander ou envoyer des donn√©es, en suivant une structure sp√©cifique.

Elle commence par une **ligne de requ√™te** comme :

	GET /index.html HTTP/1.1


Viennent ensuite une s√©rie d'**en-t√™tes** avec des informations suppl√©mentaires (comme le nom de l'h√¥te ou les pr√©f√©rences de langue : `Host`, `User-Agent`, etc.), suivis d'une ligne vide, et parfois d'un **corps** (surtout dans les requ√™tes `POST`).

Le serveur lit et interpr√®te la requ√™te, puis renvoie une **r√©ponse HTTP structur√©e**.

***‚Üí Les requ√™tes HTTP sont expliqu√©es en d√©tail dans le fichier `HTTP1.1.fr.md`***

#### HTML (HyperText Markup Language)

> **HTML** est un **langage de balisage** utilis√© pour structurer et afficher du contenu sur les pages web.

Un fichier HTML est une **ressource** que le serveur peut livrer au client.

Exemple simple :

```html
<html>
  <head><title>Ma page</title></head>
  <body><h1>Bonjour !</h1></body>
</html>
```

#### HTML (HyperText Markup Language)

Le serveur Webserv ne parse pas le HTML ‚Äî **il l'envoie simplement tel quel**.
C'est le navigateur qui est responsable de son interpr√©tation.


#### Socket

Un **socket** est une **interface logicielle** (un morceau de code √† l'int√©rieur d'un programme) qui permet la communication sur un r√©seau en utilisant des protocoles comme TCP ou UDP.

Dans Webserv :

- Le serveur cr√©e un socket avec `socket()`
- Le lie √† une adresse et un port avec `bind()`
- √âcoute les connexions entrantes avec `listen()`
- Accepte les connexions avec `accept()`

En C/C++, un socket est repr√©sent√© par un **descripteur de fichier** (un `int`), ce qui permet d'utiliser des fonctions standard comme `read()` et `write()` pour la communication r√©seau.


#### Port

Un **port** est un **num√©ro logique** utilis√© pour identifier une **application sp√©cifique** sur une machine.

- Le **Port 80** est le **port par d√©faut pour HTTP**
- Le **Port 443** est utilis√© pour **HTTPS**
- Le **Port 8080** est souvent utilis√© comme **alternative au port 80**, notamment :
  - lorsque vous n'avez pas les privil√®ges root
  - pour les serveurs de d√©veloppement/test locaux

> Le serveur Webserv √©coute sur un port (par ex., `8080`) pour accepter les connexions HTTP.


#### TCP (Transmission Control Protocol)

**TCP** est un **protocole de transport fiable** utilis√© pour transmettre des donn√©es entre deux machines sur un r√©seau, en s'assurant que les donn√©es :

- arrivent dans le **bon ordre**
- ne sont **pas perdues**
- ne sont **pas dupliqu√©es**

Contrairement √† d'autres protocoles comme UDP (qui est rapide mais non fiable), TCP √©tablit une **connexion stable** (une session) entre deux points d'extr√©mit√© avant de transmettre des donn√©es.

HTTP est construit sur TCP, ce qui signifie :

- Une requ√™te HTTP est envoy√©e **√† travers un flux TCP**
- Webserv utilise un **socket TCP** pour recevoir les requ√™tes
- Les clients peuvent compter sur une **transmission compl√®te et ordonn√©e** des messages

> Gr√¢ce √† TCP, le serveur peut lire une requ√™te HTTP **en toute s√©curit√©**, sans avoir √† g√©rer manuellement l'ordre ou l'int√©grit√© des paquets.


#### UDP (User Datagram Protocol)

**UDP** est un **protocole de transport rapide mais non fiable**, utilis√© pour envoyer de **petits paquets de donn√©es** sans √©tablir de connexion pr√©alable.

Contrairement √† TCP, UDP ne **garantit pas** :

- Que les paquets arrivent **dans le bon ordre**
- Que les paquets arrivent **tout court** (la perte de paquets est possible)
- Que les paquets ne sont **pas dupliqu√©s**

UDP est donc :

- **Plus l√©ger**
- **Plus rapide**
- Mais aussi **moins fiable**

Chaque message envoy√© est appel√© un **datagramme**, ind√©pendant des autres.
UDP n'offre **aucune v√©rification d'erreur ni retransmission**.

Il est souvent utilis√© pour :

- Les jeux en ligne
- Le streaming vid√©o en temps r√©el
- Les requ√™tes DNS
- Les applications qui tol√®rent une certaine perte de donn√©es

> En bref, **UDP √©change la fiabilit√© contre la vitesse**, ce qui le rend adapt√© aux communications o√π **la r√©activit√© compte plus que la perfection**.


#### CGI (Common Gateway Interface)

**CGI** est une **interface standard** qui permet √† un serveur web d'**ex√©cuter un programme externe** (comme un script PHP ou Python) et de **retourner sa sortie comme une r√©ponse HTTP**.

Webserv doit :

- D√©tecter qu'un fichier est un **script CGI**
- Appeler `fork()` pour cr√©er un processus enfant
- Utiliser `execve()` pour ex√©cuter le script
- Lire la sortie du script (via un pipe)
- Renvoyer cette sortie comme r√©ponse HTTP

***‚Üí Le CGI est expliqu√© en d√©tail dans le fichier `CGI.fr.md`***

### Fonctions Autoris√©es

Le projet Webserv autorise l'utilisation de tout ce qui est compatible avec **C++98**, sans Boost ni autres biblioth√®ques externes.
Le sujet liste de nombreuses fonctions de niveau syst√®me, qui peuvent √™tre regroup√©es en cat√©gories :

#### Gestion et Ex√©cution de Processus

> Ces fonctions permettent au serveur de **lancer des programmes externes (comme les scripts CGI)**, de **g√©rer les processus enfants** et de **rediriger leurs entr√©es/sorties**.

| Fonction | Objectif Principal |
| :--- | :--- |
| `execve` | Ex√©cute un programme externe (par ex., un script CGI) |
| `fork` | Cr√©e un processus enfant (utilis√© pour le CGI) |
| `waitpid` | Attend la fin d'un processus enfant |
| `kill` | Envoie un signal √† un processus |
| `signal` | D√©finit un gestionnaire personnalis√© pour un signal (par ex., `SIGINT`) |
| `errno` | Variable globale contenant le dernier code d'erreur syst√®me |
| `strerror` | Renvoie un message lisible pour la valeur `errno` actuelle |


#### Redirection et Duplication de Descripteurs de Fichiers

> Utilis√© pour **rediriger l'entr√©e/sortie standard**, notamment pour l'ex√©cution de CGI et la gestion des pipes.

| Fonction | Objectif Principal |
| :--- | :--- |
| `dup` | Duplique un descripteur de fichier |
| `dup2` | Duplique un descripteur vers une cible sp√©cifique |
| `pipe` | Cr√©e une paire de descripteurs connect√©s pour l'IPC |


#### R√©seau ‚Äî **Sockets**

> Ce sont des fonctions essentielles pour construire un **serveur web TCP**, accepter des connexions et envoyer/recevoir des requ√™tes.

| Fonction | Objectif Principal |
| :--- | :--- |
| `socket` | Cr√©e un socket TCP |
| `bind` | Lie un socket √† une adresse IP et un port |
| `listen` | Met le socket en mode √©coute |
| `accept` | Accepte une connexion entrante |
| `connect` | Initie une connexion √† un socket distant |
| `recv` | Re√ßoit des donn√©es d'un socket |
| `send` | Envoie des donn√©es via un socket |
| `setsockopt` | Configure des options sur un socket |
| `getsockname` | R√©cup√®re l'adresse locale d'un socket |
| `socketpair` | Cr√©e une paire de sockets connect√©s (par ex., pipe CGI bidirectionnel) |


#### Multiplexage d'E/S ‚Äî **G√©rer Plusieurs Connexions Simultan√©ment**

> Ces interfaces permettent au serveur de **surveiller plusieurs sockets** pour la disponibilit√© en lecture/√©criture sans utiliser de threads.

| Interface | Fonctions Associ√©es |
| :--- | :--- |
| `select` | M√©thode portable, limit√©e √† 1024 descripteurs de fichiers |
| `poll` | Plus flexible que `select`, supporte plus de fds |
| `epoll` | Pour Linux : `epoll_create`, `epoll_ctl`, `epoll_wait` |
| `kqueue` | Pour macOS : `kqueue`, `kevent` |


#### R√©solution de Noms et Configuration R√©seau

> Ces fonctions aident √† **traduire les noms d'h√¥tes en IP**, √† configurer les protocoles et √† g√©rer les ports.

| Fonction | Objectif Principal |
| :--- | :--- |
| `getaddrinfo` | R√©sout un nom d'h√¥te (par ex., `localhost` ‚Üí adresse IP) |
| `freeaddrinfo` | Lib√®re la m√©moire allou√©e par `getaddrinfo` |
| `getprotobyname` | R√©cup√®re le num√©ro d'un protocole (par ex., `"tcp"`) |
| `htons`, `htonl` | Convertit les entiers en ordre d'octets r√©seau |
| `ntohs`, `ntohl` | Convertit les entiers **depuis** l'ordre d'octets r√©seau |


#### Acc√®s aux Fichiers et au Syst√®me de Fichiers

> Utilis√© pour **servir des fichiers HTML, des images, etc.**, v√©rifier l'existence et les permissions, et parcourir les r√©pertoires.

| Fonction | Objectif Principal |
| :--- | :--- |
| `access` | V√©rifie si un fichier existe ou a les bonnes permissions |
| `stat` | R√©cup√®re les m√©tadonn√©es d'un fichier |
| `open`, `read`, `write`, `close` | Ouvre, lit, √©crit et ferme un fichier |
| `chdir` | Change le r√©pertoire de travail courant (par ex., pour le CGI) |
| `opendir`, `readdir`, `closedir` | Ouvre, lit et ferme des r√©pertoires |

---

### Cycle de Vie d'une Connexion HTTP dans Webserv

#### 1. **Initialisation du Serveur**

- `socket()` ‚Üí cr√©e un socket d'√©coute (`SOCK_STREAM`)
- `setsockopt()` ‚Üí active l'option `SO_REUSEADDR`
- `bind()` ‚Üí lie le socket √† un `host:port` sp√©cifique
- `listen()` ‚Üí met le socket en mode √©coute
- `epoll_create()` / `poll()` ‚Üí met en place le m√©canisme de boucle d'√©v√©nements


#### 2. **Attente de Connexions (√âv√©nement `EPOLLIN` ou `POLLIN`)**

- `accept()` ‚Üí accepte une connexion entrante
- `epoll_ctl(ADD)` ‚Üí ajoute le nouveau socket client √† l'ensemble poll/epoll
- le socket client est mis en **mode non bloquant**


#### 3. **R√©ception de la Requ√™te HTTP**

- `recv()` ‚Üí lit la requ√™te depuis le socket client
- `parse()` ‚Üí analyse :
  - la m√©thode HTTP (GET, POST‚Ä¶)
  - l'URI / chemin
  - les en-t√™tes (Host, Content-Length‚Ä¶)
  - le corps optionnel (par ex., pour POST)


#### 4. **Traitement de la Requ√™te**

- **Fichier statique :**
  - `access()` ‚Üí v√©rifie si le fichier existe et si l'acc√®s est autoris√©
  - `stat()` ‚Üí r√©cup√®re la taille/type du fichier
  - `open()` + `read()` ‚Üí lit le fichier demand√©
  - construit une **r√©ponse HTTP compl√®te**

- **Script CGI :**
  - `fork()` ‚Üí cr√©e un processus enfant
  - `pipe()` / `socketpair()` ‚Üí met en place la communication avec le CGI
  - `dup2()` ‚Üí redirige `stdin` et `stdout`
  - `execve()` ‚Üí ex√©cute le script
  - `waitpid()` ‚Üí attend que le CGI se termine
  - `read()` ‚Üí lit la sortie du CGI
  - parse et **injecte la sortie dans la r√©ponse HTTP**


#### 5. **Envoi de la R√©ponse**

- `send()` ‚Üí envoie la r√©ponse HTTP (en-t√™tes + corps)
- (optionnel : passer de `EPOLLIN` √† `EPOLLOUT` en mode non bloquant)


#### 6. **Fermeture de la Connexion**

- `close()` ‚Üí ferme le socket client (ou `epoll_ctl(DEL)`)
- ou le **keep-alive** est maintenu en fonction de l'en-t√™te `Connection: keep-alive` et de la configuration du timeout


#### R√©sum√© du Traitement d'une Requ√™te

```text
le client se connecte ‚Üí accept() ‚Üí recv() ‚Üí parse()
          ‚Üì
  [fichier statique]      [script CGI]
       ‚Üì                      ‚Üì
access/stat/open     fork() ‚Üí execve()
       ‚Üì                      ‚Üì
     read()                 pipe/read
       ‚Üì                      ‚Üì
 r√©ponse HTTP             r√©ponse HTTP
          ‚Üì
        send()
          ‚Üì
       close()
```

---

### Multiplexage

#### D√©finition du Multiplexage (alias **Multiplexage d'E/S**)

> Le **multiplexage** fait r√©f√©rence √† la capacit√© d'un programme √† **surveiller plusieurs sources d'entr√©e/sortie simultan√©ment** sans bloquer, et √† r√©agir **d√®s que l'une d'entre elles devient active** (par ex., un socket pr√™t pour la lecture ou l'√©criture).

Au lieu de faire :

```cpp
read(socket1);
read(socket2);
read(socket3);
```

### Multiplexage

#### ...et de bloquer sur chaque socket ?

Au lieu de bloquer sur chaque socket un par un, on demande √† l'OS :

> ‚ÄúPr√©viens-moi d√®s que **l'un d'entre eux** a quelque chose √† dire.‚Äù

---

### Le Multiplexage dans Webserv

Le serveur doit :

- √âcouter **plusieurs clients simultan√©ment**
- **√âviter de bloquer** sur des sockets inactifs
- **R√©agir imm√©diatement** lorsqu'un client devient pr√™t

Le multiplexage permet de faire tout cela avec un **seul thread/processus**, de mani√®re **non bloquante** et **efficace**.

> ‚ö†Ô∏è Le sujet interdit explicitement d'utiliser `fork()` ou des threads pour g√©rer plusieurs connexions :
>
> *"Vous ne pouvez pas utiliser fork pour autre chose que le CGI (comme PHP ou Python, etc.)."*


### M√©canismes de Multiplexage Courants

Le sujet autorise le choix d'**un seul et unique** m√©canisme de multiplexage.
Vous ne devez **jamais appeler `read()` ou `write()`** √† moins que le m√©canisme choisi n'ait confirm√© que le descripteur de fichier est pr√™t.

| M√©canisme | Syst√®mes Support√©s | Niveau |
| :--- | :--- | :--- |
| `select()` | POSIX (Linux, macOS) | Basique |
| `poll()` | POSIX (Linux, macOS) | Interm√©diaire |
| `epoll()` | Linux uniquement | Avanc√© |
| `kqueue()` | BSD/macOS uniquement | Avanc√© |


#### 1. `select()`

Cette fonction utilise des **ensembles statiques (`fd_set`)** et des macros comme `FD_SET`.

**Avantages :**
- Tr√®s simple √† comprendre
- Universel (support√© partout)

**Inconv√©nients :**
- Limit√© √† **1024 descripteurs de fichiers** (`FD_SETSIZE`)
- Mauvaises performances avec de nombreux sockets (scan lin√©aire)
- Syntaxe verbeuse et rigide


#### 2. `poll()`

Cette fonction utilise un **tableau dynamique de structures `pollfd`** ‚Äî un bon choix portable.

**Avantages :**
- Pas de limite de 1024 FD
- Interface plus propre que `select()`
- Disponible sur tous les syst√®mes POSIX

**Inconv√©nients :**
- Utilise toujours un **scan lin√©aire**
- N√©cessite de reconstruire le tableau √† chaque it√©ration


#### 3. `epoll()` (Linux uniquement)

Une interface **pilot√©e par les √©v√©nements** con√ßue pour de hautes performances.

**Avantages :**
- Tr√®s rapide : O(1) pour `add`, `remove`, et `wait`
- Id√©al pour des **milliers de connexions concurrentes**
- Ne retourne que les **FDs pr√™ts**

**Inconv√©nients :**
- Sp√©cifique √† Linux
- API l√©g√®rement plus complexe (`epoll_create`, `epoll_ctl`, `epoll_wait`)
- Non portable


#### 4. `kqueue()` (macOS / BSD)

√âquivalent de `epoll()` pour BSD/macOS.

**Avantages :**
- Hautes performances (similaires √† `epoll`)
- Peut aussi surveiller des **fichiers, signaux et timers**

**Inconv√©nients :**
- Sp√©cifique √† macOS/BSD
- Syntaxe plus verbeuse (`kqueue`, `kevent`, etc.)


### Contraintes de Multiplexage pour Webserv

Le serveur **Webserv** doit :

- Fonctionner en **mode non bloquant**
- Utiliser un **unique m√©canisme de multiplexage** (`poll()`, `select()`, `epoll()`, ou `kqueue()`)
- L'utiliser pour g√©rer **toutes les E/S**, y compris :
  - Le **socket d'√©coute**
  - Les **sockets clients**
  - Les **pipes de communication CGI**


### R√®gles Obligatoires

- Utiliser **une boucle principale**
- Un seul appel √† `poll()` (ou √©quivalent) par it√©ration
- Cet appel doit surveiller :
  - Les **sockets pr√™ts √† lire** (`POLLIN`)
  - Les **sockets pr√™ts √† √©crire** (`POLLOUT`)
- Vous ne devez **pas appeler `read()`/`recv()` ou `write()`/`send()`** √† moins que le m√©canisme de polling ne confirme la disponibilit√©
- Vous ne devez **pas vous fier aux valeurs de `errno`** (par ex., `EAGAIN`) pour g√©rer la disponibilit√© ‚Äî cela doit √™tre √©vit√© en utilisant `poll()` ou un √©quivalent


### Exception : Lecture du Fichier de Configuration

La lecture du fichier `.conf` **peut √™tre faite en mode bloquant**.
Ces r√®gles **s'appliquent uniquement aux op√©rations d'E/S sur les sockets et les pipes**.


### Notes pour `select()`

Si vous choisissez d'utiliser `select()`, les macros suivantes sont **requises** pour g√©rer les descripteurs de fichiers surveill√©s :

- `FD_ZERO` ‚Äî Efface un ensemble de descripteurs
- `FD_SET`  ‚Äî Ajoute un descripteur √† l'ensemble
- `FD_CLR`  ‚Äî Retire un descripteur de l'ensemble
- `FD_ISSET` ‚Äî V√©rifie si un descripteur est pr√™t (lecture/√©criture)

> Ces macros sont **essentielles avec `select()`**,
> mais elles ne sont **pas utilis√©es avec `poll()` ou `epoll()`**.

---

### Telnet et NGINX

`telnet` et `nginx` sont des **outils en ligne de commande (CLI)** qui peuvent vous aider √† comprendre et √† tester Webserv.
Ils sont utiles pour :

- Tester manuellement des **requ√™tes HTTP brutes**, en combinant `telnet` et `nginx` pour apprendre comment une requ√™te/r√©ponse HTTP est structur√©e
- Voir comment le serveur r√©agit √† des requ√™tes mal form√©es ou minimales
- Tester votre propre serveur Webserv en envoyant des requ√™tes HTTP via `telnet`

---

#### Telnet

> `telnet` est un **client r√©seau en ligne de commande** qui vous permet d'**ouvrir une connexion TCP** vers un h√¥te et un port donn√©s.
> C'est tr√®s utile pour **envoyer manuellement des requ√™tes HTTP** et observer la **r√©ponse HTTP brute** du serveur.

Lancez `telnet` comme ceci :

```bash
telnet <h√¥te> <port>

# par exemple :
telnet localhost 8080    # port par d√©faut sur macOS
telnet localhost 80      # port par d√©faut sur Linux
```

#### Telnet ‚Äî Taper une Requ√™te HTTP Brute

Une fois connect√©, `telnet` vous donne une invite o√π vous pouvez taper une **requ√™te HTTP brute ligne par ligne**, en terminant par une **ligne vide** (appuyez deux fois sur Entr√©e) pour signaler la fin de la requ√™te.

Exemple d'une requ√™te HTTP brute dans `telnet` :

	GET / HTTP/1.1
	Host: localhost


Si `nginx` (ou Webserv) est √† l'√©coute sur le port donn√©, il recevra la requ√™te et **renverra une r√©ponse HTTP**, qui appara√Ætra directement dans le terminal.


#### NGINX

`nginx` est un **serveur HTTP haute performance et largement utilis√©**, souvent d√©ploy√© dans des environnements de production.
Il sert de r√©f√©rence utile pour comprendre **comment un serveur HTTP du monde r√©el g√®re les requ√™tes**.

Dans le contexte de **Webserv**, `nginx` est utile pour :

- Comparer le **comportement de votre serveur** avec NGINX (m√™me lors de l'√©valuation ‚Äî NGINX est la r√©f√©rence)
- Observer les **r√©ponses aux cas d'erreur** (par ex., `404 Not Found`, `405 Method Not Allowed`)
- √âtudier la **structure d'un fichier de configuration** (`nginx.conf`)
- L'utiliser comme **mod√®le** pour √©crire votre propre fichier `.conf` pour Webserv


##### D√©marrer `nginx`

```bash
brew services start nginx    # sur macOS (port par d√©faut : 8080)
sudo systemctl start nginx   # sur Linux (port par d√©faut : 80)
```

V√©rifier si nginx est en cours d'ex√©cution :

	lsof -i :8080    # sur macOS
	lsof -i :80      # on Linux
